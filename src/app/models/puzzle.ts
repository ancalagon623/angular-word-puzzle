export enum PuzzleOptions {
  BBTheRoad,
  JKJourney,
  GKCCHeese,
  GKCTraveler
}

export interface RawPuzzleData {
  id: PuzzleOptions;
  tag: string;
  solution: string;
  complexity: number;
  obscurity: number;
}

export class Puzzle {
  id: number;
  private _fullSolution: string;
  private _puzzlePieces: string[] = [];
  private _complexity: number;
  private _obscurity: number;
  private _difficulty: number;

  private static difficultyMultipliers = [1.5, 2, 3];
  private static fillers = ['Nope.', 'Nothin\'.', 'So close!', 'Close, but no cigar', 'Fry, fry a hen', 'Missed it by *that* much'];

  /**
   * Rounds a given number to the closest number that is a multiple of another number. 
   * This is useful for determining the length of the puzzle pieces array.
   * @param num 
   * @param multipleOf 
   * @returns number
   */
  static roundToNearestMultiple (num: number, multipleOf: number) {
    const remainder = num % multipleOf;
    if (remainder < (multipleOf / 2)) {
      return num - remainder;
    } else {
      return num + (multipleOf - remainder);
    }
  }

  constructor (puzz: RawPuzzleData) {
    this.id = puzz.id;
    this._fullSolution = puzz.solution;
    this._complexity = puzz.complexity;
    this._obscurity = puzz.obscurity;
    this._difficulty = 1;
    this.generatePuzzleFromSolution();
  }

  /**
   * This method is called in the constructor on instatiation of the puzzle, and anytime the puzzle pieces need to be recreated from the difficulty level and the solution phrase. 
   * 
   * The puzzle pieces are generated by first using the difficulty multipliers and the number of words in the solution to calculate the number of cards the puzzle contains and populating the list with the solution words and filler words.
   * 
   * Then the puzzle pieces are shuffled in place with the shuffle method.
   * 
   * @returns: a reference to the newly recreated and reshuffled puzzlePieces array attached to the current class instance
   */
  generatePuzzleFromSolution () {
    this.puzzlePieces = [];

    const solutionWords = this._fullSolution.trim().split(/\s\s|\s/);

    // calculate the length that the puzzle ought to be, based on the difficulty multipliers.
    const numOfCards = Puzzle.roundToNearestMultiple(Puzzle.difficultyMultipliers[this.difficultyLevel] * solutionWords.length, 5);

    for (let ix = 0; ix < numOfCards; ix++) {
      if (solutionWords[ix]) {
        this.puzzlePieces.push(solutionWords[ix]);
      } else {
        // we have finished looping through the solution pieces. Add fillers.
        // First pick a random piece from the filler array.
        const fillerPiece = Puzzle.fillers[Math.round(Math.random() * (Puzzle.fillers.length - 1))]
        this.puzzlePieces.push(fillerPiece);
      }
    }

    this.shuffle();

    return this.puzzlePieces;
  }

  shuffle () {
    if (!this.puzzlePieces || !this.puzzlePieces.length) {
      console.warn('No puzzle pieces to shuffle. Not expected, may want to look into this.');
      return;
    };

    const targetArray = Array(this.puzzlePieces.length).fill('');

    for (let ix = 0; ix < this.puzzlePieces.length; ix++) {

      const openSlots = targetArray.map((slot, ix) => {
        return {orginalIX: ix, value: slot};
      }).filter((obj) => obj.value === '');

      const randSlot = openSlots[Math.round(Math.random() * (openSlots.length - 1))];

      targetArray[randSlot.orginalIX] = this.puzzlePieces[ix];
    }

    this.puzzlePieces = targetArray;
  }

  get fullSolution () {
    return this._fullSolution;
  }

  set fullSolution (value: string) {
    this._fullSolution = value;
    this.generatePuzzleFromSolution();
  }

  get puzzlePieces () {
    return this._puzzlePieces;
  }

  set puzzlePieces (list: string[]) {
    this._puzzlePieces = list;
  }

  get obscurity () {
    return this._obscurity;
  }

  get complexity () {
    return this._complexity;
  }

  get difficultyLevel () {
    return this._difficulty;
  }

  set difficultyLevel (level: number) {
    if ([0, 1, 2].includes(level)) {
      this.generatePuzzleFromSolution();
      this._difficulty = level;
    } else {
      throw Error('Not a valid difficulty level: level is: ' + level)
    }
  }

}